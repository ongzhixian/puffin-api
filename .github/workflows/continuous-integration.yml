name: Continuous Integration

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    name: Deploy to lambda
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: pwsh
    strategy:
      matrix:
        aws_lambda:
          - function_name: puffin_sample1
            handler: sample.sample_lambda1
            runtime: python3.10
          - function_name: puffin_sample2
            handler: sample.sample_lambda2
            runtime: python3.10

    steps:
      - uses: actions/checkout@v4

      - name: List files (for debugging)
        run: ls -R

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # Note: Kept for reference; This offers a more customizable way to package the Lambda function.
      #       Unfortunately, there does not seem to be a way to expose the resulting zip file as an artifact.
      #       Using `actions/upload-artifact` to package this zip file will result a nested zip file (zip file of zip file) result.
      #       So, we are using `actions/upload-artifact` to package the source files instead.
      #       However, we later find that we cannot reference the result zip file created by `actions/upload-artifact`
      #       *roll-eyes and give-up* So doing double packaging instead.
      # - name: Packaging Lambda Function
      #   run: |
      #     $publish_file_path = '${{ vars.LAMBDA_ZIP_FILE_PATH }}'
      #     [string[]]$file_list = Get-ChildItem ${{ vars.LAMBDA_SRC_FOLDER_PATH }}
      #     $archive_specs = @{
      #       Path = $file_list
      #       DestinationPath = $publish_file_path
      #     }
      #     Compress-Archive @archive_specs -Force

      # Note: Create artifact; More of a proof-of-concept step in this example
      #       The common use-case is to expose what we are packaging as distributables.
      #       Arguably we can view this elsewhere in the case of AWS Lambda but what other tech stack may be more limiting.
      - name: Create AWS Lambda Function artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.aws_lambda.function_name }}-package                # Name of the artifact (aws-lambda-package.zip)
          path: |                                 # Note: Use unix style path (./). Does not work with Windows style path (.\).
            ${{ vars.LAMBDA_SRC_FOLDER_PATH }}  

      # - name: Deploy AWS Lambda Function
      #   run: |
      #     $publish_file_path = '${{ vars.LAMBDA_ZIP_FILE_PATH }}'
      #     Write-Host "Publishing to AWS Lambda with profile: $awsProfile"
      #     $listFunctionsResponse = aws lambda list-functions | ConvertFrom-Json
      #     $functionNameList = $listFunctionsResponse.Functions | Select-Object -ExpandProperty FunctionName
      #     if ($functionNameList -contains 'bridge_example_test') {
      #       Write-Host "Updating existing Lambda function"
      #       aws lambda update-function-code `
      #       --function-name bridge_example_test `
      #       --zip-file fileb://$publish_file_path | ConvertFrom-Json
      #     } else {
      #       Write-Host "Creating new Lambda function"
      #       aws lambda create-function `
      #       --function-name bridge_example_test `
      #       --runtime python3.10 `
      #       --zip-file fileb://$publish_file_path `
      #       --handler github_service.example `
      #       --role ${{ vars.AWS_LAMBDA_ROLE_ARN }}
      #     }

      # Note: Kept for reference; Use for testing what happens when we download the artifact.
      #       Originally, we use the `actions/upload-artifact@v4` to create deployment package and expose it as artifact.
      #       The thought was that we can then reuse the artifact in another workflow to deploy the Lambda function.
      #       However, it seems that the resulting artifact cannot be made available.
      #       `actions/download-artifact@v4` extracts the contents of the zip file; it does not download the artifact (zip file) itself.
      #       So, we go back to the terrible idea of doing packaging twice.
      # - name: Download AWS Lambda Function Package Artifact
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: aws-lambda-package
      #     path: ./publish

      - name: List files (for debugging)
        run: ls -R

      - name: Deploy ${{ matrix.aws_lambda.function_name }}
        uses: aws-actions/aws-lambda-deploy@v1
        with:
          function-name: ${{ matrix.aws_lambda.function_name }}
          code-artifacts-dir: ${{ vars.LAMBDA_SRC_FOLDER_PATH }}
          handler: ${{ matrix.aws_lambda.handler }}
          runtime: ${{ matrix.aws_lambda.runtime }}
          role: ${{ vars.AWS_LAMBDA_ROLE_ARN }}
          tags: '{"environment": "production", "project": "puffin", "version": "0.1.0"}'


      # # Runs a single command using the runners shell
      # - name: Run a one-line script
      #   run: echo Hello, world!

      # # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #   run: |
      #     echo Add other actions to build,
      #     echo test, and deploy your project.
